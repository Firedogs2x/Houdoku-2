<!-- Generated by SpecStory, Markdown v2.0.0 -->

<!-- vscode Session 56049bc7-94bd-4211-a732-358df51bd64e (2025-11-17 02:57Z) -->

# Chapter data loading and refresh process analysis (2025-11-17 02:57Z)

_**User (2025-11-17 05:02Z)**_

I need to figure out how this software reads and loads the chapter data that is read when the Refresh button is selected or when a new series is added.
Can you create a detailed explanation of what files handles this process and what each file does.  


---

_**Agent (model copilot/auto)**_

I'll create a short plan (TODOs) then search the repo for code related to "Refresh" and chapter loading.Now I'll search the repository for likely identifiers (Refresh, chapter, loadChapters, getChapters).Next I'll search the desktop renderer and services for chapter-related code and UI hooks.**Analyzing file structures**

I’m starting to think about analyzing the flow of files, particularly focusing on services connected to series and chapters. I’ll first look into the 'series' model and the 'chapter' model within the renderer or main files. It makes sense to search for 'Series' model types and 'Chapter' type definitions. I should use a grep_search for 'interface Chapter' or check out '@tiyo/common'. My plan is to search for the 'Chapter' symbol specifically.Now I'll search for the `Chapter` model and series-related services in the desktop source.Searching specifically for 'refreshSeries' and other refresh function names next.**Exploring app functionality**

I'm considering that the app might use IPC channels, particularly something like 'refresh-series' or just 'refresh'. To investigate this, I plan to search for 'refresh' by itself in the specified directory, apps/desktop/src. I'll use a grep search, making sure it's case-insensitive to catch any variations. This way, I can gather all relevant instances related to the refresh functionality in the app, making sure I’m thorough in my search!**Accessing library file**

I'm noticing that the 'library/utils.tsx' has entries like 'Refreshing library...' which probably indicates a refresh function. I think the next step is to open that file to see what's going on. I'll use the read_file tool, making sure to add a brief preamble as per the guidelines. Then I’ll call read_file for the specific path to get the details I need. Let's see what insights we can gather!I'll open `utils.tsx` to inspect the refresh implementation.**Searching for functions in UI**

I’m looking at a file that shows functions for loading chapter lists using library.fetchChapters, as well as the 'reloadSeries' and 'reloadSeriesList' functions that rely on IPC to get chapters and update the library. The Refresh button probably triggers one of these reload functions for a specific series. I need to locate where the UI actually calls reloadSeriesList or reloadSeries, so I’ll use grep_search to find those usages.I'll open `SeriesDetailsBanner.tsx` and `LibraryControlBar.tsx` to see where the Refresh UI triggers `reloadSeriesList`.**Searching for IPC handlers**

I need to find the main process handlers for the channel 'extension-getChapters' and others. My first step is to check in the apps/desktop/src/main directory for any handlers related to ipcMain. I’ll look specifically for patterns like ipcMain.handle, handle(channel), or ipcMain.on using a grep search. This will help me ensure I'm targeting the right files and functions to understand how the communication is set up.**Searching for extension channels**

I need to find out where extension channels are managed, which might be in the main process extension manager service. I remember searching for 'EXTENSION.GET_CHAPTERS' before, so it seems like the main handlers could invoke the extension manager, which then calls the plugins. Now, I should look for the string 'extension-getChapters' to see if that leads me to the right place. Let's get to it!**Exploring page requester data**

I'm looking into how the page requester data is obtained and how GET_PAGE_URLS is invoked. The function getPageUrls returns page filenames, and it seems ReaderPage transforms them to the 'atom://' scheme through a protocol handler. I'm curious about the location of the protocol handler — I noticed that in main/index.ts, it had the protocol.handle 'atom' at line 137. I think I should check around that area in the file.**Inspecting importSeries usage**

I’m looking into the persistent store using localStorage to save JSON strings. That seems solid! Next, I want to inspect the renderer code where importSeries is involved, particularly in DashboardPage and Library. From what I remember, DashboardPage possibly uses importSeries for adding new series. So, I’ll open up the parts of DashboardPage that reference importSeries to get a clearer picture of how it functions.**Reviewing import functions**

I see that the importSeries function is invoked when a new series is added through the importQueue mechanism. It uses ipcRenderer to fetch chapters and perform upserts in the library. I should also mention the downloadCover function, along with how thumbnails are handled in reloadSeries. There are calls to FILESYSTEM.GET_THUMBNAIL_PATH and DELETE_THUMBNAIL, while downloadCover utilizes ipcChannels. I'll need to check out renderer/util/download.ts for more insights.**Explaining file roles**

I need to provide a detailed explanation for each file, highlighting its role and how the call flow works. It sounds like a bit of a task, but it’s essential to clarify what each file does and how they interact with each other. I suppose breaking it down file by file will help ensure everything is understood correctly. Let’s get to work on that! I'm looking forward to laying it all out clearly.**Detailing file roles**

I need to outline the roles of several files in the project. For example, `LibraryControlBar.tsx` has a refresh button that reloads the filtered series list. Then, `SeriesDetailsBanner.tsx` refreshes details for a single series when triggered. The `utils.tsx` file contains core functions for loading series and chapters and managing library updates. `library.ts` handles persisting data via localStorage, while `persistantStore.ts` focuses on read/write operations. Finally, `extension.ts` takes care of IPC handlers for various requests, and `index.ts` sets up protocol handlers and registers IPC for plugins.**Inspecting IPC handlers**

I need to look into `createFilesystemIpcHandlers` to understand how it connects with the IPC functions like `GET_CHAPTER_DOWNLOADED`. I'll check the implementation in `main/services/filesystem.ts` for clarity. It's crucial to see how it all fits together, so I'll open that file next. Since I've noticed it's imported elsewhere, I think searching for its occurrences will help me gather more context. I'll tackle that now to ensure I have a comprehensive understanding of its role.[object Object]

---

_**User (2025-11-17 05:16Z)**_

@agent Continue: "Continue to iterate?"

---

_**Agent (model copilot/auto)**_

**Explaining filesystem functions**

I need to mention the main filesystem functions like `walk` and `getChapterDownloadPath`. However, I’m not sure if I need to go too deep into the details. It might be sufficient to open the files `main/util/filesystem.ts` and `archives.ts` to explain functions like `extract` and `walk`. Let's take a look at `main/util/filesystem.ts` to see what we can find!**Updating task statuses**

I need to update the list of tasks since we've already opened many files. Steps 2 and 3 are completed, and step 4 is in progress. I should use the manage_todo_list function to replace the full list. I'll make sure to include all items: id1 and id2 completed, id3 completed, id4 is in progress, and id5 has not started yet. Before calling the tool, I must send a preamble about the update.Updating the TODO list to mark repository search and file inspection steps as completed, and starting the write-up.**Correcting todo list format**

It seems that my tool call failed because of malformed JSON. I need to create a proper todoList array that includes items with IDs from 1 to 5. I’ll make sure to use the correct JSON format. The plan is to set id1, id2, and id3 as completed, id4 as in-progress, and id5 as not started. After that, I’ll call manage_todo_list again and include a brief preamble.Progress update: I've searched the codebase and inspected the key files that implement chapter loading and the Refresh/import flows. Next I'll provide a detailed, file-by-file explanation of how chapter data is read and loaded (both for Refresh and when adding a new series).

Detailed explanation (files + responsibilities + call sequence)
- Summary of the high-level flow
  - UI triggers (Refresh button or import) call renderer helpers that invoke IPC to the main process extension layer.
  - The main process dispatches to an extension client (either the filesystem extension or a web extension via the Tiyo client).
  - The extension's getChapters / getSeries / getPageRequesterData / getPageUrls / getImage functions return metadata and page lists (for filesystem, these operate on real files).
  - The renderer receives the chapters and upserts them into the local library (persisted via localStorage). The reader uses GET_PAGE_REQUESTER_DATA and GET_PAGE_URLS to build page URLs, and the app serves local files via a custom `atom://` protocol registered in main.

- UI files that trigger refresh / add-series
  - `LibraryControlBar.tsx`
    - Contains the top-level "Refresh" button in library view.
    - Calls `reloadSeriesList(props.getFilteredList(), setSeriesList, setReloadingSeriesList, chapterLanguages)` when pressed.
  - `SeriesDetailsBanner.tsx`
    - Contains a per-series "Refresh" button (for a single series).
    - Calls `reloadSeriesList([series], setSeriesList, setReloadingSeriesList, chapterLanguages)`.

- Renderer helper that implements Refresh and import logic
  - `utils.tsx`
    - Key functions:
      - `importSeries(series, chapterLanguages, getFirst=false)`:
        - When adding a new series: calls `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_CHAPTERS, extensionId, sourceId)` (and optionally GET_SERIES to fill details) to fetch chapters from the content source.
        - Uses `library.upsertSeries(...)` and `library.upsertChapters(chapters, addedSeries)` to persist the series and its chapters locally.
        - Updates unread counts and triggers download of cover thumbnails if needed.
      - `reloadSeries(series, chapterLanguages)`:
        - For a single series refresh: ensures extension exists, calls `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_SERIES, ...)` and `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_CHAPTERS, ...)`.
        - Merges new chapters with existing persisted chapters (preserve IDs/read state), removes orphaned chapters, updates unread counts, and refreshes thumbnails if remote cover changed.
      - `reloadSeriesList(seriesList, setSeriesList, setReloadingSeriesList, chapterLanguages)`:
        - Iterates series (sorted), calls `reloadSeries` for each, shows toasts for progress/errors, and finally updates the UI `seriesList` from `library.fetchSeriesList()`.
      - `loadSeries`, `loadChapterList`, `markChapters`, `getFromChapterIds`:
        - `loadChapterList(seriesId, setChapterList)` loads chapter list for UI by calling `library.fetchChapters(seriesId)` (reads persisted data).

- Local library persistence
  - `library.ts`
    - Implements `fetchSeriesList`, `fetchSeries`, `fetchChapters`, `fetchChapter`, `upsertSeries`, `upsertChapters`, `removeSeries`, `removeChapters`, etc.
    - Storage is JSON strings written via `persistantStore` under keys defined in `storeKeys.json`. Chapter lists are per-series keys.
    - `upsertChapters` merges incoming chapters with existing ones, assigning UUIDs if needed.
  - `persistantStore.ts`
    - Simple wrapper around `window.localStorage` (`read`, `write`, `remove`). So the library is persisted in the renderer's localStorage.

- IPC channel definitions
  - `ipcChannels.json`
    - Lists channels such as `EXTENSION.GET_SERIES` => `"extension-getSeries"`, `EXTENSION.GET_CHAPTERS` => `"extension-getChapters"`, `FILESYSTEM.*`, etc.

- Main process: dispatch to extensions / filesystem / helpers
  - `extension.ts`
    - Registers IPC handlers (via `ipcMain.handle(...)`) for extension-related channels:
      - `EXTENSION.GET_SERIES` → `getSeries(extensionId, seriesId)`
      - `EXTENSION.GET_CHAPTERS` → `getChapters(extensionId, seriesId)`
      - `EXTENSION.GET_PAGE_REQUESTER_DATA`, `EXTENSION.GET_PAGE_URLS`, `EXTENSION.GET_IMAGE`, `EXTENSION.SEARCH`, etc.
    - `getSeries`, `getChapters`, `getPageRequesterData`, etc., call into an extension client (either filesystem extension client or Tiyo plugin's extension client).
    - `createExtensionIpcHandlers` sets up `ipcMain` handlers and `loadPlugins` creates the Tiyo client and loads installed web-based extensions.
  - `index.ts`
    - Sets up the main BrowserWindow and calls `createExtensionIpcHandlers(ipcMain, spoofWindow)` and `loadPlugins(spoofWindow)`.
    - Registers a custom protocol handler for `atom://` that maps to `` and uses `net.fetch` so the renderer can load local files via `atom://` URLs.

- Filesystem extension implementation (local files / archive support)
  - `filesystem.ts`
    - Implements `getSeries`, `getChapters`, `getPageRequesterData`, `getPageUrls`, and `getImage` for the built-in filesystem extension used when series.extensionId === filesystem id.
    - `getChapters(id)`:
      - Walks files under provided `id` path (uses `walk` util) to build a set of chapter paths (directories or archive files).
      - Builds Chapter objects with `sourceId` pointing to either the chapter directory path or the archive file path; assigns metadata like `chapterNumber`, `groupName` using filename parsing (`parseChapterMetadata`).
    - `getPageRequesterData(...)`:
      - For archive files, calls `extract(archivePath, extractPath)` and returns `pageFilenames`. For directories, lists image files.
    - `getPageUrls` returns page file paths (the Reader maps these to `atom://` URLs).

- Filesystem utilities used by extension and main
  - `filesystem.ts`
    - `walk(directory)` recursively lists all files (used by `getChapters`).
    - `listDirectory`, `getChapterDownloadPath`, `getChaptersDownloaded`, `getChapterDownloaded`, `downloadThumbnail`, `getThumbnailPath`, `deleteThumbnail`, etc., used in download/thumbnail and download management.

- Reader: loading a chapter and page images
  - `ReaderPage.tsx`
    - When opening a chapter, it calls:
      - `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_PAGE_REQUESTER_DATA, series.extensionId, series.sourceId, chapter.sourceId)`
      - Then `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_PAGE_URLS, series.extensionId, pageRequesterData)`
    - For filesystem extension, the returned page URLs are converted to `atom://` scheme in the renderer:
      - `newPageUrls = newPageUrls.map((pageUrl) => 'atom://' + encodeURIComponent(pageUrl))`
    - `pageUrls` state is then used by `ReaderViewer` to render <img> tags; the `atom://` protocol is handled by `index.ts` to fetch local file data.

- Thumbnail / cover download
  - `download.ts`
    - Calls `EXTENSION.GET_IMAGE` to get image data for series.remoteCoverUrl then invokes `FILESYSTEM.DOWNLOAD_THUMBNAIL` to save it to thumbnail path.
  - `filesystem.ts` + `filesystem.ts` handle thumbnail path calculation and saving.

Call sequence (Refresh button, single series)
1. User clicks "Refresh" on SeriesDetailsBanner or LibraryControlBar.
2. Component calls `reloadSeriesList([series], ...)` (or list of series).
3. `reloadSeriesList` calls `reloadSeries(series)` for each series.
4. `reloadSeries` in renderer does:
   - Calls `ipcRenderer.invoke(ipcChannels.EXTENSION_MANAGER.GET, series.extensionId)` to ensure extension exists.
   - Calls `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_SERIES, extensionId, sourceId)` to fetch up-to-date series metadata (if not filesystem).
   - Calls `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_CHAPTERS, extensionId, sourceId)` to fetch chapters list.
5. The main process IPC handler (in `extension.ts`) dispatches to the matching extension client's `getChapters` implementation.
   - For filesystem: `FSExtensionClient.getChapters` uses `walk()` to discover chapter directories and archive files, creates Chapter objects.
   - For web-based content: Tiyo plugin's extension client implements getChapters by scraping/parsing the site.
6. The renderer receives the list of Chapter objects via the IPC response.
7. `reloadSeries` merges the new chapters with existing ones (preserving IDs/read statuses), calls `library.upsertSeries` and `library.upsertChapters` which write JSON into `localStorage` via `persistantStore`.
8. UI updates (the calling component refreshes `seriesList` and `chapterList` via `library.fetchSeriesList()` / `library.fetchChapters(seriesId)`).

Call sequence (Add new series / Import)
1. The import flow pushes an import task into `importQueue` (see `DashboardPage.tsx`).
2. `importSeries(series, chapterLanguages, getFirst)` is called.
3. `importSeries` optionally retrieves full series metadata via `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_SERIES, ...)`.
4. Calls `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_CHAPTERS, extensionId, sourceId)` to obtain chapter list.
5. On success it calls `library.upsertSeries` and `library.upsertChapters` so the series and chapters persist locally; UI then reads them from `library.fetchSeriesList()` and `library.fetchChapters()`.

How the reader loads page images (after chapters are stored)
- Reader calls `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_PAGE_REQUESTER_DATA, extensionId, seriesSourceId, chapterSourceId)` to get PageRequesterData.
- Then calls `ipcRenderer.invoke(ipcChannels.EXTENSION.GET_PAGE_URLS, extensionId, pageRequesterData)` to get page URLs.
- For filesystem extension the returned file paths are converted to `atom://` URLs in the renderer; the main process registered a protocol handler that converts `atom://` to `` and serves the file bytes to the renderer via `net.fetch`.
- For web extensions, the extension's `getImage` / `getPageUrls` implement fetching images (GET_IMAGE IP C channel used by `downloadCover` and download manager).

Files worth inspecting for debugging or tracing
- Renderer:
  - `utils.tsx` — central; add logs here to trace reload/import flows.
  - `library.ts` — persistence layer; inspect stored keys and JSON format in localStorage.
  - `LibraryControlBar.tsx` and `SeriesDetailsBanner.tsx` — UI triggers.
  - `ReaderPage.tsx` — page loading flow using GET_PAGE_REQUESTER_DATA & GET_PAGE_URLS.
- Main:
  - `extension.ts` — IPC handlers for extension calls (GET_CHAPTERS/GET_SERIES/etc).
  - `filesystem.ts` — FS implementation (how chapter directories and archives are discovered and parsed).
  - `index.ts` — `atom://` protocol registration and `createExtensionIpcHandlers` call site.
  - `filesystem.ts` — helper functions like `walk`, `getChapterDownloadPath`, `getThumbnailPath` (useful for local-file behavior).
- Shared / constants:
  - `ipcChannels.json` — channel names used across renderer <-> main.
  - `temp_fs_metadata.ts` — filesystem extension metadata id used to detect filesystem extension.

Short suggestions to trace/inspect live behavior
- Add console.debug or breakpoints in:
  - `reloadSeries` in `utils.tsx` (to see returned chapters and merge behavior).
  - `filesystem.ts` `getChapters` to see what chapter paths it discovers for a given directory.
  - `ReaderPage.tsx` before and after the GET_PAGE_URLS invocation to inspect page URLs.
- To inspect persisted data: open devtools in the renderer and inspect `localStorage` keys used by `storeKeys.json` (values are JSON strings containing Series[] and Chapter[]).
- To see files served by the protocol, log `req.url` in `index.ts` protocol handler (already decodes and fetches file:// URL).

Would you like:
- A runnable trace patch that adds temporary console.debug logs at key points (I can create a small patch to add logs to `reloadSeries`, `FSExtensionClient.getChapters`, and the Reader page)?  
- Or a minimal sequence of steps and commands you can run locally (e.g., enabling renderer devtools, searching `localStorage` keys, or printing `localStorage` contents) to observe the flows?

If you want, I can make and apply a small instrumenting patch now.

---

