<!-- Generated by SpecStory, Markdown v2.1.0 -->

<!-- vscode Session cf600eeb-316f-4d71-a99d-5e08362959e9 (2025-11-19 19:59Z) -->

# Backup JSON file creation and restoration process (2025-11-19 19:59Z)

_**User (2025-11-19 20:03Z)**_

 I want to look at how this program creates the backup json file.
Please review and give a detail description of what files handle the format.


---

_**Agent (model copilot/auto)**_

I'll search the repo for backup/export-related identifiers and JSON writes to find the code that creates backup files. I'll scan for "backup", "export", and ".json" write patterns across TypeScript/JS files.**Reviewing backup file**

I need to check the matches pointing to the backup.ts file. To do this, I’ll read the file and review its content. I’ll provide a brief explanation before making the tool call, like “Reading the backup file for review.” Then, I’ll use the functions.read_file to grab the lines. Since the file is probably small, I can read a range of 1-400 lines to ensure I have all the relevant information.Next I'll open `backup.ts` to inspect how it constructs and writes the backup JSON.**Reviewing file descriptions**

I need to provide a detailed description of the files that handle a specific format. I'll look for other files that contribute to this format, starting with localStorage keys, specifically focusing on storeKeys. It’s important to inspect storeKeys.json and possibly the library service, updateSeries, and any other code impacting localStorage, as that will determine the backup JSON content. I’ll use grep_search to find usages and definitions of storeKeys, starting with a preamble before my search.Next I'll locate the store key definitions and code that writes library/chapters/series into localStorage to describe the backup format. I'll search for `storeKeys` and localStorage usages.I'll open `apps/desktop/src/renderer/common/constants/storeKeys.json`, `library.ts`, and `persistantStore.ts` to map keys and storage behavior.**Examining directory structure**

I'm trying to resolve the path that points to '@/common/constants/storeKeys.json' in backup.ts. This seems to lead to apps/desktop/src/renderer/common/constants, which got me wondering about the actual file structure. I'll check if there's a common folder in src/renderer. To clarify this, I should list the directory using functions.list_dir to view that specific folder. Let's start there!**Exploring file locations**

I'm trying to track down where "common/constants" is located. I recall that there's also "apps/desktop/src/common" mentioned earlier. It seems like the import statement '@/common/constants/storeKeys.json' could reference files under "apps/desktop/src/common/constants". I think the next step is to check that directory, so I can see if everything's organized like I expect. Let's see what I find there!**Exploring file paths**

I'm considering if the path is relative, specifically `../features/library/utils` in `backup.ts` compared to `apps/desktop/src/renderer/util`. I wonder if the file `utils.ts` actually exists at `apps/desktop/src/renderer/features/library/`. It seems logical to check the features folder to confirm. Let me list what's in there to see if that file is present.**Identifying localStorage usage**

I'm thinking about backup content and how it's essentially JSON.stringify(localStorage). I need to be aware that localStorage includes keys set in storeKeys.json and possibly other settings too. It's crucial to identify any other components writing to localStorage, like settings or trackers. I should search for where persistantStore.write and window.localStorage.setItem are used. I've already noticed persistantStore.write in various files, like services and settings. So, I'll grep for its usage to clarify.**Explaining restoreBackup behavior**

I'm looking into how the restoreBackup function works. It parses content into an object and checks for the 'library-series-list' key, then converts it into a JSON array for upserting series using updateSeries. It goes through chapter-prefixed keys to restore chapters, merging read flags as needed. Notably, it seems restoreBackup doesn't cover settings or extension tokens — it focuses on series and chapters only. On the other hand, createAutoBackup writes to the filesystem using fs.writeJson, which may indicate fs-extra is globally registered. I need to consider how autoBackupCountState fits into this.**Clarifying storage and planning steps**

I should mention that the values used are usually stringified JSON from persistStore.write, which employs window.localStorage.setItem. Many modules also apply JSON.stringify when dealing with complex data. Now, according to the important reminders, I must start by using the manage_todo_list tool, which I accidentally overlooked earlier since the instructions emphasized using it first for multi-step tasks. Oops! I’ll call manage_todo_list now to record our plan, which includes: 1) Add a todo list with three steps: "Search for backup creation code," "Inspect backup util and related store keys," and "Describe format and list responsible files." Then, I’ll mark those as completed.**Preparing the todo list**

Okay, I'm seeing that I need to include all items when writing the todo list, along with their statuses. I’ll mark the first two items as completed since we’ve done them, and the last one can also be marked as completed since we've found everything. However, I remember that the instructions say to mark one item as in-progress before starting. Even though I didn't start with the todo list, I can still track our progress now. I’ll use manage_todo_list to write, providing a one-sentence preamble before the tool call. Then I'll present the report to the user!**Updating Progress and Next Steps**

I need to provide a concise progress update after completing multiple read-only calls. The final answer must follow the formatting guidelines, with small headers in Title Case and bullets highlighting keywords. I’ll include a section titled "Files Involved," where I list the relevant files and give brief descriptions. Next, I’ll detail the "Format Details," covering key names and value types. I'll summarize the specifics of createBackup, createAutoBackup, and restoreBackup under "Backup Creation & Restore Behavior." Finally, I'll mention that restores only bring back library items, not settings or extensions, and suggest next steps like opening specific files or adding improvements. Now, let’s call manage_todo_list!I'll add a short todo list tracking the investigation steps and mark them completed (done while exploring).Progress update: I located and inspected the relevant files that create and restore backups. Next, a concise detailed description of the format and the files that handle it.

**Files Involved**
- `backup.ts`:
  - Functions: `createBackup`, `createAutoBackup`, `restoreBackup`.
  - Role: Creates the downloadable backup (client-side Blob) and automatic filesystem backup files; parses a backup JSON string and restores library data (series + chapters).
- `storeKeys.json`:
  - Role: Defines the canonical localStorage keys and prefixes the app uses (e.g., `library-series-list`, `library-chapters-`, `general-`, `reader-`, `extension-settings-`, `tracker-access-token-`). This determines key names that appear in the backup JSON.
- `persistantStore.ts`:
  - Role: Thin wrapper around `window.localStorage` (`read`, `write`, `remove`). All code that persists data calls this, so it determines how values are written into localStorage (strings).
- `library.ts`:
  - Role: Serializes/deserializes library data. Writes:
    - `library-series-list` -> JSON.stringify(Series[])
    - `library-chapters-<seriesId>` -> JSON.stringify(Chapter[])
    - `library-category-list` -> JSON.stringify(Category[])
  - Reads and writes using `persistantStore`, so complex objects are stored as JSON strings.
- `utils.ts`:
  - Role: Writes many settings using prefixes from `storeKeys.json` (e.g., `general-<key>`, `reader-<key>`). Settings are written as plain strings (booleans as `'true'`/`'false'`, arrays as comma-separated strings, numbers as stringified ints). The code also includes parsing logic to convert those stored strings back into typed settings.
- `utils.tsx`:
  - Role: Provides `updateSeries` and import logic used by `restoreBackup` to upsert series and chapters into the live library.
- `ipc.tsx` and related components:
  - Role: Read extension settings and tracker tokens from localStorage keys like `extension-settings-<id>` and `tracker-access-token-<id>` and pass them to the main/IPC layer during startup; these keys appear in backups if present.
- Other components that write to localStorage:
  - `PluginSettingsModal.tsx`, `components/settings/TrackerAuth*.tsx`, and many features use `persistantStore.write(...)`. These produce additional keys stored in the backup object.

**Backup File Format (what's actually written)**
- The code that creates the backup uses:
  - `createBackup`: `JSON.stringify(localStorage)` -> creates a JSON object mapping localStorage keys to their string values and saves it as a downloadable `.json` file named `houdoku_backup_YYYY-MM-DD.json`.
  - `createAutoBackup`: also uses `JSON.stringify(localStorage)` and writes a file to `./backups/houdoku_backup_YYYY-MM-DD.json` (keeps a rolling set based on configured count).
- Therefore the backup JSON is a single top-level object whose properties are localStorage keys and values are strings. Example structure:
  {
    "library-series-list": "[{\"id\":\"...\",\"title\":\"...\"}, ...]",
    "library-chapters-<seriesId>": "[{\"id\":\"...\",\"read\":true,...}, ...]",
    "general-someSetting": "true",
    "reader-someSetting": "2",
    "extension-settings-<extId>": "{\"someExtKey\":\"value\"}",
    "tracker-access-token-<trackerId>": "token-string",
    ...
  }
- Note: values for complex data (series, chapters, categories, extension settings) are JSON-encoded strings. Primitive settings are stored as plain strings and parsed by setting utilities.

**Restore Behavior (what `restoreBackup` does)**
- `restoreBackup(backupFileContent: string)`:
  - Parses the backup JSON into an object.
  - If `library-series-list` exists, it:
    - Parses that value (JSON.parse of the string) to a `Series[]`.
    - Calls `updateSeries(series)` for each series — this uses `library.upsertSeries` and also triggers cover download handling.
  - For keys that start with the chapter prefix (`library-chapters-`), it:
    - Extracts `seriesId` from the key.
    - Fetches the existing series (via `library.fetchSeries(seriesId)`); if none, skips that chapter list.
    - Parses the stored chapter list, then merges each old chapter with existing chapters (prefers the existing chapter's `read` flag when present), and calls `library.upsertChapters` to store them.
- Important: `restoreBackup` only explicitly restores library series and chapters. It does not attempt to restore settings prefixes, extension settings, or tracker tokens — although those keys exist in the backup file, `restoreBackup` currently ignores them. Extension settings and tokens are loaded on startup from localStorage by other code (`ipc.tsx`), so a full restore of those would require writing those keys into `window.localStorage` (which `restoreBackup` does not do).

**Auto-backup behavior**
- `createAutoBackup`:
  - Ensures `backups` directory exists (calls `fs.mkdir('backups')`).
  - Writes file `backups/houdoku_backup_YYYY-MM-DD.json` using `fs.writeJson(...)`.
  - Keeps directory capped by Count: reads `backups` and deletes the oldest file if count exceeded.

**Key takeaways / observations**
- The backup is effectively a snapshot of `window.localStorage` (a key→string map).
- The canonical keys/prefixes are defined in `storeKeys.json` — those are the authoritative names that determine the on-disk format keys.
- Library data is stored as JSON-encoded strings (arrays of objects). Settings are stored as plain strings with app-side parsing.
- The restore function is conservative: it imports series and chapters into the existing library and merges read flags, but does not write back settings or other stored keys into `localStorage`.
  - If you want restore to fully revert settings and extension tokens, `restoreBackup` would need to write those keys back into localStorage (e.g., via `persistantStore.write`) and possibly trigger any startup handlers.
- `persistantStore.write` formats every value as a string (``${data}``), so all backups will have string values even for numeric/boolean settings.

If you want, I can:
- Show a concrete example backup file (generate a small example using current data).
- Update `restoreBackup` to also restore settings, extension settings, and tracker tokens (I'll outline and implement safe steps for that).
- Add tests or an import preview UI that shows what will be restored before applying.

Which next step would you like?

---

